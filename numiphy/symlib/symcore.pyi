from __future__ import annotations
import numpy as np
from ..findiffs import grids
from ..findiffs.grids import InterpedArray
from typing import Type, Dict, Self
from functools import cached_property


class _Expr:

    Args: tuple
    repr_priority: int
    is_symexpr: bool
    is_operator: bool
    is_analytical_expression: bool
    S: _Singleton

    def __add__(self, other)->_Expr:...
    
    def __sub__(self, other)->_Expr:...
    
    def __mul__(self, other)->_Expr:...
    
    def __truediv__(self, other)->_Expr:...
    
    def __pow__(self, other)->_Expr:...
    
    def __neg__(self)->_Expr:...
    
    def __radd__(self, other)->_Expr:...
    
    def __rsub__(self, other)->_Expr:...
    
    def __rmul__(self, other)->_Expr:...
    
    def __rtruediv__(self, other)->_Expr:...
    
    def __rpow__(self, other)->_Expr:...
    
    def __abs__(self)->_Expr:...

    def __repr__(self)->str:...

    def __str__(self)->str:...
    
    def __hash__(self)->int:...

    def __eq__(self, other)->bool:...

    def _diff(self, var: _Symbol)->_Expr:...
    
    def _equals(self, other: Type[Self])->bool:... #other must be same class as self

    @classmethod
    def _asexpr(cls, arg)->_Expr:...# also checks if it is operator or not e.g.
    
    @classmethod
    def _add(cls, *args, simplify=True)->_Expr:...# return Add.init(...)

    @classmethod
    def _mul(cls, *args, simplify=True)->_Expr:...

    @classmethod
    def _pow(cls, base, power, simplify=True)->_Expr:...

    @classmethod
    def _sin(cls, arg: _Expr, simplify=True)->_Expr:...

    @classmethod
    def _cos(cls, arg: _Expr, simplify=True)->_Expr:...

    @classmethod
    def _exp(cls, arg: _Expr, simplify=True)->_Expr:...

    @classmethod
    def _log(cls, arg: _Expr, simplify=True)->_Expr:...

    @classmethod
    def _tan(cls, arg: _Expr, simplify=True)->_Expr:...

    @classmethod
    def _abs(cls, arg: _Expr, simplify=True)->_Expr:...

    @classmethod
    def _rat(cls, m: int, n: int)->_Expr:...##### def __new__ in Rational and RationalOp

    @classmethod
    def _derivative(cls, f: _Expr, *vars: _Symbol, simplify=True)->_Expr:...

    @classmethod
    def _subs(cls, expr: _Expr, vals: Dict[_Expr, _Expr], simplify=True)->_Expr:...

    @classmethod
    def _dummy(cls, arr: np.ndarray, grid: grids.Grid, *vars: _Symbol)->_DummyScalarField:...

    @property
    def args(self)->tuple[_Expr]:...
    
    def doit(self, deep=True)->_Expr:...

    def repr(self, lang="python", lib = "")->str:...

    def get_ndarray(self, x: Dict[_Symbol, np.ndarray], **kwargs)->np.ndarray:...

    def ndarray(self, varorder: list[_Symbol], grid: grids.Grid, acc=1, fd='central')->np.ndarray:...

    def body(self)->_Expr:...
    
    def coef(self)->_Expr:...
    
    def addargs(self)->tuple[_Expr,...]:...

    def mulargs(self)->tuple[_Expr,...]:...

    def powargs(self)->tuple[_Expr, _Expr]:...

    def neg(self)->_Expr:...

    def _repr_from(self, lib: str, oper: Type[Operation])->str:...

    def replace(self, items: Dict[_Expr, _Expr])->_Expr:...

    def subs(self, vals: Dict[_Expr, _Expr])->_Expr:...

    def diff(self, var: _Symbol, order=1)->_Expr:...

    def eval(self)->_Expr:...
    
    def get_grids(self, var: _Symbol)->tuple[grids.Grid1D,...]:...
    
    @property
    def nd(self)->int:...
    
    @cached_property
    def isNumber(self)->bool:...

    @property
    def isRealNumber(self)->bool:...

    @property
    def isPosInt(self)->bool:...

    @property
    def isNegInt(self)->bool:...

    @cached_property
    def sgn(self)->int:...

    @cached_property
    def variables(self)->tuple[_Symbol,...]:...
    
    def expand(self)->_Expr:...

    def deepsearch(self)->tuple[Atom,...]:...
    
    def contains_type(self, cls: Type)->bool:...

    def init(self, *args, simplify=True)->_Expr:...

    def array(self, varorder: list[_Symbol], grid: grids.Grid, acc=1, fd='central')->np.ndarray:...
    
    def integral(self, varorder: list[_Symbol], grid: grids.Grid, acc=1, fd='central')->float:...

    def dummify(self, varorder=None, grid: grids.Grid=None, acc=1, fd='central')->_DummyScalarField:...

    def plot(self, varorder: list[_Symbol], grid: grids.Grid, acc=1, fd='central', ax=None, **kwargs):...
    
    def animate(self, var: _Symbol, varorder: list[_Symbol], duration: float, save: str, grid: grids.Grid, display = True, **kwargs):...


class Node(_Expr):

    @classmethod
    def simplify(cls, *args: _Expr)->tuple[_Expr,...]:...

    def init(self, *args, simplify=True)->_Expr:...
    
    def item(self, path: list[int])->_Expr:...


class Atom(_Expr):...


class Operation(Node):

    is_commutative: bool
    binary: str

    def __new__(cls, *args, simplify=True)->_Expr:...

    def includes(self, *args)->list[_Expr]:...

    def argsub(self, arg: _Expr, *k: int)->_Expr:...
    
    @classmethod
    def matheval(cls, *args: float)->float:...


class _Add(Operation):...


class _Mul(Operation):

    @cached_property
    def numerator(self)->_Expr:...

    @cached_property
    def denominator(self)->_Expr:...

    @cached_property
    def _coef(self)->_Expr:...

    @cached_property
    def _body(self)->_Expr:...


class _Pow(Operation):

    def __new__(cls, base, power, simplify=True)->_Expr:...

    @property
    def base(self)->_Expr:...
    
    @property
    def power(self)->_Expr:...


class _Function(Atom):

    @property
    def name(self)->str:...

    @property
    def _variables(self)->tuple[_Symbol,...]:...


class _Number(Atom):
    
    @property
    def value(self)->int|float|complex:...


class _Float(_Number):...


class _Rational(_Number):

    @property
    def n(self)->int:
        return self.Args[0]
    
    @property
    def d(self)->int:
        return self.Args[1]

    def __new__(cls, m: int, n: int)->_Expr:...


class _Integer(_Rational):

    def __new__(cls, m)->_Expr:...


class _Special(_Number):

    def __init__(self, name: str, value: float):...

    @property
    def name(self)->str:...


class _Complex(_Number):

    @property
    def real(self)->int|float:...
    
    @property
    def imag(self)->int|float:...
    
    @property
    def value(self)->complex:...


class _Symbol(Atom):

    name: str

    def __init__(self, name: str):...
    

class _Subs(Node):


    def __new__(cls, expr: _Expr, vals: Dict[_Symbol, _Expr], simplify=True)->_Expr:...

    @property
    def expr(self)->_Expr:...

    @property
    def vals(self)->Dict[_Symbol, _Expr]:...


class _Derivative(Node):

    def __new__(cls, f: _Expr, *vars: _Symbol, simplify=True)->_Expr:...

    @classmethod
    def newvars(cls, diffcount: Dict[_Symbol, int])->tuple[_Symbol, ...]:...

    @property
    def f(self)->_Expr:...
    
    @cached_property
    def symbols(self)->tuple[_Symbol, ...]:...

    @cached_property
    def diffcount(self)->Dict[_Symbol, int]:...


class _Integral(Node):

    def __new__(cls, f: _Expr, var: _Symbol, x0, simplify=True)->_Expr:...

    @property
    def f(self)->_Expr:...
    
    @property
    def symbol(self)->_Symbol:...
    
    @property
    def x0(self)->float:...
    

class _ScalarField(_Function):
    

    def __init__(self, ndarray: np.ndarray, grid: grids.Grid, name: str, *vars: _Symbol):...

    @property
    def _ndarray(self)->np.ndarray:...
    
    @property
    def grid(self)->grids.Grid:...
    
    @property
    def ndim(self)->int:...

    def to_dummy(self)->_DummyScalarField:...

    def as_interped_array(self)->InterpedArray:...

    def rearrange_as(self, *variables: _Symbol)->_ScalarField:...

    def directional_diff(self, x: tuple, direction: tuple, order=1, acc=1, fd='central')->float:...
    
    def interpolate(self, grid: grids.Grid)->_ScalarField:...

    def plot(self, varorder: list[_Symbol]=None, grid: grids.Grid=None, acc=1, fd='central', ax=None, **kwargs):...


class _DummyScalarField(_ScalarField):

    def __init__(self, ndarray: np.ndarray, grid: grids.Grid, *vars: _Symbol):...

    def _diff(self, var, acc=1, fd='central')->_DummyScalarField:...
    
    def diff(self, var: _Symbol, order=1, acc=1, fd='central')->_DummyScalarField:...
    
    def integrate(self, var: _Symbol)->_DummyScalarField:...

    def log10(self)->_DummyScalarField:...


class _Piecewise(Node):

    def __new__(cls, *cases: tuple[_Expr, Condition], default: _Expr, simplify=True)->_Expr:...

    @property
    def conds(self)->tuple[Condition,...]:...

    @property
    def default(self)->_Expr:...

    @property
    def cases(self)->tuple[tuple[_Expr, Condition],...]:...



class _Any(_Expr):...


class _Singleton:

    One: _Integer
    Zero: _Integer
    I: _Complex
    pi: _Special


from .inequalities import Condition